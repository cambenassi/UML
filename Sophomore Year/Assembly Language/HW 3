	.data
STAB:
Q0:     .word  ACT1
        .word  Q1   # T1
        .word  Q1   # T2
        .word  Q1   # T3
        .word  Q1   # T4
        .word  Q1   # T5
        .word  Q1   # T6
        .word  Q11  # T7

Q1:     .word  ACT2
        .word  Q2   # T1
        .word  Q5   # T2
        .word  Q3   # T3
        .word  Q3   # T4
        .word  Q0   # T5
        .word  Q4   # T6
        .word  Q11  # T7

Q2:     .word  ACT1
        .word  Q6   # T1
        .word  Q7   # T2
        .word  Q7   # T3
        .word  Q7   # T4
        .word  Q7   # T5
        .word  Q7   # T6
        .word  Q11  # T7

Q3:     .word  ACT4
        .word  Q0   # T1
        .word  Q0   # T2
        .word  Q0   # T3
        .word  Q0   # T4
        .word  Q0   # T5
        .word  Q0   # T6
        .word  Q11  # T7

Q4:     .word  ACT4
        .word  Q10  # T1
        .word  Q10  # T2
        .word  Q10  # T3
        .word  Q10  # T4
        .word  Q10  # T5
        .word  Q10  # T6
        .word  Q11  # T7

Q5:     .word  ACT1
        .word  Q8   # T1
        .word  Q8   # T2
        .word  Q9   # T3
        .word  Q9   # T4
        .word  Q9   # T5
        .word  Q9   # T6
        .word  Q11  # T7

Q6:     .word  ACT3
        .word  Q2   # T1
        .word  Q2   # T2
        .word  Q2   # T3
        .word  Q2   # T4
        .word  Q2   # T5
        .word  Q2   # T6
        .word  Q11  # T7

Q7:     .word  ACT4
        .word  Q1   # T1
        .word  Q1   # T2
        .word  Q1   # T3
        .word  Q1   # T4
        .word  Q1   # T5
        .word  Q1   # T6
        .word  Q11  # T7

Q8:     .word  ACT3
        .word  Q5   # T1
        .word  Q5   # T2
        .word  Q5   # T3
        .word  Q5   # T4
        .word  Q5   # T5
        .word  Q5   # T6
        .word  Q11  # T7

Q9:     .word  ACT4
        .word  Q1  # T1
        .word  Q1  # T2
        .word  Q1  # T3
        .word  Q1  # T4
        .word  Q1  # T5
        .word  Q1  # T6
        .word  Q11 # T7

Q10:	.word	RETURN
        .word  Q10  # T1
        .word  Q10  # T2
        .word  Q10  # T3
        .word  Q10  # T4
        .word  Q10  # T5
        .word  Q10  # T6
        .word  Q11  # T7

Q11:    .word  ERROR 
	.word  Q4  # T1
	.word  Q4  # T2
	.word  Q4  # T3
	.word  Q4  # T4
	.word  Q4  # T5
	.word  Q4  # T6
	.word  Q4  # T7
	
inBuf:	.space 	80	#input string
outBuf:		.word	0:3			# copy token entry to outBuf to print
tableHead:	.asciiz "TOKEN    TYPE\n"

TOKEN: 	.space 	8

tabToken:
	.word	0:30	#10 token table
	

	
	.text
	
#####################################
#
#	main driver
#
#	$t3: index to inBuf
#	$s7: index to TOKEN
#	$s6: index to type
#	$bb: index to tabToken
#	$t9: curChar
#
#	$s0: T
#	$s1: CUR
#
#####################################
main:

	li	$t0, 0
newLine:
	jal	getline
	
	li	$t3, 0		#index to inBuf
	li	$s7, 0
	la	$s1, Q0		# CUR = Q0
	li	$s0, 1		# T = 1
	li      $t8, 0   	#entryPos = 0  //keeps track of the entry position
nextState:	
	lw	$s2, 0($s1)	#ACT = STASB[CUR]
	jalr	$v1, $s2	# Save return addr in $v1

	sll	$s0, $s0, 2	# Multiply by 4 for word boundary
	add	$s1, $s1, $s0	# CUR + 4 * T
	sra	$s0, $s0, 2
	lw	$s1, 0($s1)	# CUR = STAB[CUR][T]
	b	nextState

dump:
	jal 	printTabTok
	jal 	clearInBuf
	jal 	clearToken		

	b	newLine

#######################
#
#	ACT 1:
#
#######################
ACT1:
	lb	$t9, inBuf($t3)		#curChar = inBuf[i]
	jal	lin_search		#T = lin_search($t9)
	addi	$t3, $t3, 1		#i++
	jr	$v1

#######################
#
#	ACT 2:
#
#######################
ACT2:
	sb 	$t9, TOKEN
	move 	$s6, $s0
	li	$s7, 1
	jr	$v1
	

#######################
#
#	ACT 3:
#
#######################
ACT3:
	sb	$t9, TOKEN($s7)
	addi	$s7, $s7, 1
	jr	$v1

#######################
#
#	ACT 4:
#
#######################
ACT4:
	lw	$t1, TOKEN + 0
	lw	$t2, TOKEN + 4
	
	sw	$t1, tabToken($t8)
	sw	$t2, tabToken+4($t8)
	
	addi	$s0, $s0, 0x30
	
	sw	$s0, tabToken+8($t8)
	
	addi	$t8, $t8, 12
	
	jr	$v1

#######################
#
# lin_search()
# arguments - $t9 for key
# return value - $s0 for char type
#
#######################

lin_search:
	li	$a0, 0 	#i = 0
	li	$a1, 0	#found = 0
	
rept:
	bne	$a1, 0 ret		#if(found) goto ret
	bge	$a0, 80 ret		#if(i >= 80) goto ret
	
	sll 	$a0, $a0, 3		#i * 8
	lw	$a2, Tabchar($a0)	#$a2 = Tabchar[i]
	srl	$a0, $a0, 3		#i / 8
	
	bne 	$a2, $t9 next		#if(Tabchar[i] != key) goto next
	li	$a1, 1			#found = 1
	
next: 
	addi	$a0, $a0, 1		#i++
	b 	rept
	
ret:
	sll	$a0, $a0, 3		#i / 8
	subi	$a0, $a0, 4		#i - 4
	lw	$s0, Tabchar($a0)	#$s0 = Tabchar[i]
	
	beq	$a1, 0 notF		#if(!found) goto notF
	jr	$ra
	
notF:
	li	$s0, 7			#return -1
	jr	$ra
	

#######################
#
#	ERROR:
#
#######################
ERROR:

	jr	$v1

#######################
#
#	RETURN:
#
#######################
RETURN:

	b	dump


#############################################
#
#  printTabToken:
#	print Token table header
#	copy each entry of tabToken into outBuf
#	   and print TOKEN
#	$a3 has the index (in bytes) to the last entry of tabToken
#
#############################################
printTabTok:
		li	$t7, 0x20		# blank in $t7
		li	$t6, '\n'		# newline in $t6

		la	$a0, tableHead		# print table heading
		li	$v0, 4
		syscall

		li	$t0, 0
loopTok:	bge	$t0, $s7, doneTok	# if ($t0 <= $a3)
	
		lw	$t1, tabToken($t0)	#   copy tabToken[] into outBuf
		sw	$t1, outBuf
		lw	$t1, tabToken+4($t0)
		sw	$t1, outBuf+4
	
		li	$t9, -1			# for each char in outBuf
loopChar:	addi	$t9, $t9, 1
		bge	$t9, 8, tokType		
		lb	$t8, outBuf($t9)		#   if char == Null
		bne	$t8, $zero, loopChar	
		sb	$t7, outBuf($t9)		#       replace it by ' ' (0x20)
		b	loopChar
tokType:
		sb	$t7, outBuf+8		# insert blank
		lb	$t1, tabToken+8($t0)	# $t1 = token type
		addi	$t1, $t1, 0x30		# ASCII(token type)
		sb	$t1, outBuf+9
		sb	$t6, outBuf+10		# terminate with '\n'
		sb	$0, outBuf+11
		
		la	$a0, outBuf		# print token and its type
		li	$v0, 4
		syscall
	
		addi	$t0, $t0, 12
		sw	$0, outBuf		# clear outBuf
		sw	$0, outBuf+4
		b	loopTok

doneTok:
		jr	$ra


#######################
#
#	clearInBuf:
#
#######################
clearInBuf:

	jr	$ra


#######################
#
#	clearTabToken:
#
#######################
clearToken:

	jr	$ra


##########################
#
#	getline
#
#
##########################
	.data
prompt:	.asciiz	"Enter an input string:\n"

	.text
getline: 
	la	$a0, prompt		# Prompt to enter a new line
	li	$v0, 4
	syscall

	la	$a0, inBuf		# read a new line
	li	$a1, 80	
	li	$v0, 8
	syscall

	jr	$ra
	
	
	
	.data
	
Tabchar: 	.word 	0x0a, 6		# LF
	.word 	' ', 5
 	.word 	'#', 6
	.word 	'$', 4
	.word 	'(', 4 
	.word 	')', 4 
	.word 	'*', 3 
	.word 	'+', 3 
	.word 	',', 4 
	.word 	'-', 3 
	.word 	'.', 4 
	.word 	'/', 3 

	.word 	'0', 1
	.word 	'1', 1 
	.word 	'2', 1 
	.word 	'3', 1 
	.word 	'4', 1 
	.word 	'5', 1 
	.word 	'6', 1 
	.word 	'7', 1 
	.word 	'8', 1 
	.word 	'9', 1 

	.word 	':', 4 

	.word 	'A', 2
	.word 	'B', 2 
	.word 	'C', 2 
	.word 	'D', 2 
	.word 	'E', 2 
	.word 	'F', 2 
	.word 	'G', 2 
	.word 	'H', 2 
	.word 	'I', 2 
	.word 	'J', 2 
	.word 	'K', 2
	.word 	'L', 2 
	.word 	'M', 2 
	.word 	'N', 2 
	.word 	'O', 2 
	.word 	'P', 2 
	.word 	'Q', 2 
	.word 	'R', 2 
	.word 	'S', 2 
	.word 	'T', 2 
	.word 	'U', 2
	.word 	'V', 2 
	.word 	'W', 2 
	.word 	'X', 2 
	.word 	'Y', 2
	.word 	'Z', 2

	.word 	'a', 2 
	.word 	'b', 2 	
	.word 	'c', 2 
	.word 	'd', 2 
	.word 	'e', 2 
	.word 	'f', 2 
	.word 	'g', 2 
	.word 	'h', 2 
	.word 	'i', 2 
	.word 	'j', 2 
	.word 	'k', 2
	.word 	'l', 2 
	.word 	'm', 2 
	.word 	'n', 2 
	.word 	'o', 2 
	.word 	'p', 2 
	.word 	'q', 2 
	.word 	'r', 2 
	.word 	's', 2 
	.word 	't', 2 
	.word 	'u', 2
	.word 	'v', 2 
	.word 	'w', 2 
	.word 	'x', 2 
	.word 	'y', 2
	.word 	'z', 2

	.word	0x5c, -1	# if you ‘\’ as the end-of-table symbol
