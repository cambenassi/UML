	.data

inBuf:	.space	80
outBuf:	.space	80
TOKEN:	.space	8
TYPE:	.word	0
tabToken: .word	0:30		# 10-entry token table
tableHead:	.asciiz "Token    Token Type\n"
tableHead2:	.asciiz	"-------  ------------------\n"
errormessage:	.asciiz	"Not a valid entry\n"


	.text
###############################
#
#	MAIN Driver
#
#		$t0:	increment for printTabTok
#		$t1:	temporary storage to check number of tokens left
#		$t2:	index for linear_search
#		$t3:	index to inBuf (global)
#		$t4:	index to Tabchar
#		$t5:	index in clear inBuf
#		$t6:	'\n' character
#		$t7:	' ' character
#		$t8:	temporary variable for printTabTok
#		$t9:	currChar
#		
#		$a0:	linear_search key
#		$a1:	index to token in acts
#
#		$s0:	charType
#		$s1:	currType
#		$s2:	index to Token
#		$s3:	token type
#		$s5: 	index to Tabtoken
#		$s6:	Token+0 temp
#		$s7:	Token+4 temp
#
#	
#############################
main:
newLine:
	jal	getline

	li	$t3, 0		# i of inBuf = 0
	li	$s5, 0		# i of tabtoken = 0
	la	$s1, Q0		# CUR = Q0
	li	$s0, 1		# charType = 1 
nextState:	
	lw	$s2, 0($s1)	# $s2 = STAB[CUR][0]
	jalr	$v1, $s2	# Call action; Save return addr in $v1

	sll	$s0, $s0, 2	# 4*T
	add	$s1, $s1, $s0	# CUR+4*T
	sra	$s0, $s0, 2
	lw	$s1, 0($s1)	# CUR = STAB[CUR][T]
	b	nextState

dump:	jal	printTabTok
	jal	clearInBuf
	jal	clearTabToken
	b	newLine
	
####################
#
#	ACT1:
#
#	$t3 = index to inBuf, $t9 = currChar, $a0 = linear_search key
#
####################
ACT1:
	lb	$t9,inBuf($t3)		# curChar = inBuf[i]
	addi	$t3, $t3, 1		# i++
	move	$a0, $t9		# $a0 = lin_search key
	jal	lin_search		# 
	move	$s0, $v0		# chartType = lin_search(currChar)
	jr	$v1
	
	
###########################
#
#	ACT2
#	$t9 = currChar, $s3 = tokenType, $a1 = index to token
#
###########################
ACT2:
	sw	$t9, TOKEN		# Token[i] = currChar
	move 	$s3, $s0		# tokenType = charType
	li	$a1, 1			# int i = 1
	jr	$v1


###########################
#
#	ACT3
#	$t9 = currChar, $a1 = index to token
#
###########################
ACT3:
	bge	$a1, 8, ERROR
	sb	$t9, TOKEN($a1)		#Token[i] = currChar
	addi	$a1, $a1, 1		#i++
	jr	$v1


###########################
#
#	ACT4
#	$s6 & $s7 = temp variables, $s5 = index of tabToken
#
###########################
ACT4:
	lw	$s6, TOKEN		#$s6 = Token
	lw	$s7, TOKEN + 4		#$s7 = Token+4
	
	sw	$s6, tabToken + 0($s5)	#tabToken(j) = Token
	sw	$s7, tabToken + 4($s5)	#tabToken+4(j) = Token
	
	sw	$s3, tabToken + 8($s5)	#tabToken+8(j) = tokenType
	
	addi	$s5, $s5, 12		#j += 12
	
	jal 	clearToken
	jr	$v1


###########################
#
#	Error
#
###########################
ERROR:
	la	$a0, errormessage
	li	$v0, 4
	syscall
	
	jal	clearInBuf
	jal	clearTabToken
	jal 	clearToken
	b	newLine
	

###########################
#
#	Return
#
###########################
RETURN:
	b	dump
	




##########################3
#
#	getline
#	
#
##########################
	.data
prompt:	.asciiz	"Enter an input string:\n"

	.text
getline: 
	la	$a0, prompt		# Prompt to enter a new line
	li	$v0, 4
	syscall

	la	$a0, inBuf		# read a new line
	li	$a1, 80	
	li	$v0, 8
	syscall

	jr	$ra
	
	
###########################
#
#	lin_search
#	$a0 = key, returns to $v0
#
###########################	
lin_search:
	li	$t2, 0			#int i = 0
	li	$v0, 7			#returnValue = 7
	
loop:
	lb	$t4, Tabchar($t2)	#$t4 = Tabchar(i)
	bne	$a0, $t4 notEqual	#if(key == Tabchar(i)
	lw	$v0, Tabchar + 4($t2)	#returnValue = Tabchar+4(i)
	jr	$ra
	
notEqual:				#else
	addi	$t2, $t2, 8		#i += 8
	j	loop
	
	
	

########################################################
#
#  printTabToken:
#	print Token table header
#	copy each entry of tabToken into outBuf
#	   and print TOKEN
#	$a3 has the index (in bytes) to the last entry of tabToken
#
########################################################
printTabTok:
		li	$t7, 0x20		# blank in $t7
		li	$t6, '\n'		# newline in $t6

		la	$a0, tableHead		# print table heading
		li	$v0, 4
		syscall
		la	$a0, tableHead2
		syscall
		

		li	$t0, 0
loopTok:	bge	$t0, 120, doneTok	# if ($t0 <= 120)
		
		lw	$t1, tabToken+8($t0)	#load tabToken+8($t0) into temp storage
		beq	$t1, 0 doneTok		#checks to see if next token is 0, if so skips
		
		lw	$t1, tabToken($t0)	#   copy tabToken[] into outBuf
		sw	$t1, outBuf
		lw	$t1, tabToken+4($t0)
		sw	$t1, outBuf+4
	
		li	$t9, -1			# for each char in outBuf
loopChar:	addi	$t9, $t9, 1
		bge	$t9, 8, tokType		
		lb	$t8, outBuf($t9)		#   if char == Null
		bne	$t8, $zero, loopChar	
		sb	$t7, outBuf($t9)		#    replace it by ' ' (0x20)
		b	loopChar
tokType:
		sb	$t7, outBuf+8		# insert blank
		lb	$t1, tabToken+8($t0)	# $t1 = token type
		addi	$t1, $t1, 0x30		# ASCII(token type)
		sb	$t1, outBuf+9
		sb	$t6, outBuf+10		# terminate with '\n'
		sb	$0, outBuf+11
		
		la	$a0, outBuf		# print token and its type
		li	$v0, 4
		syscall
	
		addi	$t0, $t0, 12
		sw	$0, outBuf		# clear outBuf
		sw	$0, outBuf+4
		b	loopTok

doneTok:
		jr	$ra
	

###########################
#
#	clearInBuf
#
###########################
			
clearInBuf:
	li	$t3, 0  		# i = 0
cLoop:
	bge	$t3, 80, cDone	 	# if (i >= 80) goto cDone
	sb	$0, inBuf($t3)  	# inBuf[i] = 0
	addi    $t3, $t3, 1 		# index += 1
	j	cLoop  			# goto cLoop
cDone:
	li	$t3, 0  		# bufIndex = 0
	
###########################
#
#	clearTabToken
#
###########################
	
clearTabToken:
	li	$t3, 0  		# i = 0
ctLoop:
	bge	$t3, 120, ctEnd  	# if (i >= 4*30) goto ctt_end
	sw	$0, tabToken($t3)  	# tabToken[i] = 0
	addi    $t3, $t3, 4  		# i += 4
	j	ctLoop
ctEnd:
	jr	$ra
	
	
###########################
#
#	clearToken
#
###########################
clearToken:

	sw	$0, TOKEN + 0($0)  	# Token[0:12] = 0
	sw	$0, TOKEN + 4($0)
	sw	$0, TOKEN + 8($0)  	
	
	li	$a1, 0  		# tokIndex = 0
	
	li	$s3, 0  		# tokType = 0
	jr	$ra

#############################	
	.data

STAB:
Q0: 	.word  ACT1 # ACT
	.word  Q1   # T1
	.word  Q1   # T2
	.word  Q1   # T3
	.word  Q1   # T4
	.word  Q1   # T5
	.word  Q1   # T6
	.word  Q11  # T7

Q1:	.word  ACT2 # ACT
	.word  Q2   # T1
	.word  Q5   # T2
	.word  Q3   # T3
	.word  Q3   # T4
	.word  Q4   # T5
	.word  Q0   # T6
	.word  Q11  # T7

Q2:	.word  ACT1 # ACT
	.word  Q6   # T1
	.word  Q7   # T2
	.word  Q7   # T3
	.word  Q7   # T4
	.word  Q7   # T5
	.word  Q7   # T6
	.word  Q11  # T7

Q3:	.word  ACT4 # ACT
	.word  Q0   # T1
	.word  Q0   # T2
	.word  Q0   # T3
	.word  Q0   # T4
	.word  Q0   # T5
	.word  Q0   # T6
	.word  Q11  # T7

Q4:	.word  ACT4 # ACT
	.word  Q10  # T1
	.word  Q10  # T2
	.word  Q10  # T3
	.word  Q10  # T4
	.word  Q10  # T5
	.word  Q10  # T6
	.word  Q11  # T7

Q5:	.word  ACT1 # ACT
	.word  Q8   # T1
	.word  Q8   # T2
	.word  Q9   # T3
	.word  Q9   # T4
	.word  Q9   # T5
	.word  Q9   # T6
	.word  Q11  # T7

Q6:	.word  ACT3 # ACT
	.word  Q2   # T1
	.word  Q2   # T2
	.word  Q2   # T3
	.word  Q2   # T4
	.word  Q2   # T5
	.word  Q2   # T6
	.word  Q11  # T7

Q7:	.word  ACT4 # ACT
	.word  Q1   # T1
	.word  Q1   # T2
	.word  Q1   # T3
	.word  Q1   # T4
	.word  Q1   # T5
	.word  Q1   # T6
	.word  Q11  # T7

Q8:	.word  ACT3 # ACT
	.word  Q5   # T1
	.word  Q5   # T2
	.word  Q5   # T3
	.word  Q5   # T4
	.word  Q5   # T5
	.word  Q5   # T6
	.word  Q11  # T7

Q9:	.word  ACT4 # ACT
	.word  Q1  # T1
	.word  Q1  # T2
	.word  Q1  # T3
	.word  Q1  # T4
	.word  Q1  # T5
	.word  Q1  # T6
	.word  Q11 # T7

Q10:	.word  RETURN # ACT
	.word  Q10  # T1
	.word  Q10  # T2
	.word  Q10  # T3
	.word  Q10  # T4
	.word  Q10  # T5
	.word  Q10  # T6
	.word  Q11  # T7

Q11:	.word  ERROR # ACT
	.word  Q4  # T1
	.word  Q4  # T2
	.word  Q4  # T3
	.word  Q4  # T4
	.word  Q4  # T5
	.word  Q4  # T6
	.word  Q4  # T7
	
Tabchar: 
	.word 	0x0a, 6		# LF
	.word 	' ', 6
 	.word 	'#', 5
	.word 	'$',4
	.word 	'(', 4 
	.word 	')', 4 
	.word 	'*', 3 
	.word 	'+', 3 
	.word 	',', 4 
	.word 	'-', 3 
	.word 	'.', 4 
	.word 	'/', 3 

	.word 	'0', 1
	.word 	'1', 1 
	.word 	'2', 1 
	.word 	'3', 1 
	.word 	'4', 1 
	.word 	'5', 1 
	.word 	'6', 1 
	.word 	'7', 1 
	.word 	'8', 1 
	.word 	'9', 1 

	.word 	':', 4 

	.word 	'A', 2
	.word 	'B', 2 
	.word 	'C', 2 
	.word 	'D', 2 
	.word 	'E', 2 
	.word 	'F', 2 
	.word 	'G', 2 
	.word 	'H', 2 
	.word 	'I', 2 
	.word 	'J', 2 
	.word 	'K', 2
	.word 	'L', 2 
	.word 	'M', 2 
	.word 	'N', 2 
	.word 	'O', 2 
	.word 	'P', 2 
	.word 	'Q', 2 
	.word 	'R', 2 
	.word 	'S', 2 
	.word 	'T', 2 
	.word 	'U', 2
	.word 	'V', 2 
	.word 	'W', 2 
	.word 	'X', 2 
	.word 	'Y', 2
	.word 	'Z', 2

	.word 	'a', 2 
	.word 	'b', 2 
	.word 	'c', 2 
	.word 	'd', 2 
	.word 	'e', 2 
	.word 	'f', 2 
	.word 	'g', 2 
	.word 	'h', 2 
	.word 	'i', 2 
	.word 	'j', 2 
	.word 	'k', 2
	.word 	'l', 2 
	.word 	'm', 2 
	.word 	'n', 2 
	.word 	'o', 2 
	.word 	'p', 2 
	.word 	'q', 2 
	.word 	'r', 2 
	.word 	's', 2 
	.word 	't', 2 
	.word 	'u', 2
	.word 	'v', 2
	.word 	'w', 2 
	.word 	'x', 2 
	.word 	'y', 2
	.word 	'z', 2

	.word	0x5c, -1	# if you ‘\’ as the end-of-table symbol
