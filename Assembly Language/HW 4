	.data
	
#variables
saveReg:	.word	0:10
token:		.word 	0x20202020:3			
tokArray:	.word	0x20202020:60			
inBuf:		.space	80
symTab:		.word	0:40

#text prompts
space:		.asciiz	"          "
prompt:		.asciiz	"Enter a new input line. \n"
error_message:	.asciiz	"There has been an error. \n"	
hex_prefix:	.asciiz	"0x"
header:	.asciiz	"Token              Value             Status     \n"
dash:		.asciiz	"---------------------------------------------\n"
new_line:	.asciiz	"\n"
	
############################################
#
#	Cam Benassi	HW 4
#	
#	GLOBALS:
#	$t4 = oldStatus
#	$s0 = LOC
#	$s1 = index to symTab
#	$s2 = index to inBuf
#	$s3 = index to tokArray
#	$s4 = initalState
#	$s5 = currentType
#	$s6 = DEFN
#	$s7 = isComma
#	$a1 = newStatus
#	
#
#
############################################	
	.text

	li	$s0, 0x400	#LOC = 0x400
	li	$s1, 0		#index to symTab = 0
	
newLine:
	jal 	getline
	
	li	$s2, 0		#index to inBuf = 0
	li	$s3, 0		#index to tokArray = 0

	la	$t9, Q0			#initial state Q0
driver:	
	lw	$s4, 0($t9)		#store the action routine in $s4, execute it
	jalr	$v1, $s4	

	sll	$s5, $s5, 2		#compute byte offset of T
	add	$t9, $t9, $s5		#locate the next state
	la	$t9, ($t9)
	lw	$t9, ($t9)		#next State in $t9
	sra	$s5, $s5, 2		#reset $s5
	b	driver			#loop
	
dump:
	lb	$t8, tokArray	#checks to see if token is '#'
	beq	$t8, '#', exit
	li	$s3, 0		#index to tokArray[][]

nextTok:
	lb	$t7, tokArray+12($s3)	#loads token into $t7
	bne	$t7, ':', operator	#checks if token is colon
	lw	$t6, tokArray+0($s3)	#gets next token
	sw	$t6, token		#storing token
	lw	$t6, tokArray+4($s3)
	sw	$t6, token+4
	li	$s6, 1			#DEFN = 1
	jal 	VAR
	addi	$s3, $s3, 24		#skip token

operator:
	addi	$s3, $s3, 12		#increments token index
	li	$s7, 1			#isComma = 1

chkVar:
	lb	$t5, tokArray+0($s3)
	beq	$t5, '#', poundDump
	bne	$s7, 1, nextVar		#checks if isComma == 1
	lb	$t5, tokArray+10($s3)   
	subi	$t5, $t5, 0x30
	bne	$t5, 2, nextVar
	lw	$t6, tokArray+0($s3)	#gets next token
	sw	$t6, token
	lw	$t6, tokArray+4($s3)
	sw	$t6, token+4
	li	$s6, 0			#DEFN = 0
	jal	VAR		

nextVar:
	lb	$t5, tokArray+0($s3)	# check if token is ','
	beq	$t5, 0x2C, isCommaTrue		#if equal goto isCommaTrue
	bne	$t5, 0x2C, isCommaFalse		#else, goto isCommaFalse

isCommaTrue:
	li	$s7, 1			#isComma = 1
	j	incrementTokArray

isCommaFalse:
	li	$s7, 0			#isComma = 0
	j	incrementTokArray

incrementTokArray:
	addi	$s3, $s3, 12		#increments tokArray
	b	chkVar			

####################
#
# poundDump
# Called when a pound is scanned
#
####################
poundDump:
	jal	clearInBuf		
	jal	clearTokArray		
	jal	clearTok
	jal	printSymTab
	addi	$s0, $s0, 4		#increment LOC by 4
	b 	newLine			

####################
#
# exit
# Exits the program
#
####################
exit:
	li	$v0, 10		#ends the program
	syscall

VAR:
	sw	$ra, saveReg
	jal	searchSymTab		#symIndex returns to $t8
	bge	$t8, $zero, else	#if $t8 >= 0 goto else
	li	$s5, 0x4
	or	$a1, $s5, $s6		#newStatus
	jal	saveSymTab
	b	preSymACTS

else:
	sw	$t4, saveReg+4		#$t4 = oldStatus
	lw	$t4, symTab+12($t8)
	and	$a1, $t4, 0x2
	and	$t4, $t4, 0x1
	sll	$t4, $t4, 1
	or	$a1, $a1, $t4
	or	$a1, $a1, $s6
	sw	$a1, symTab+12($t8)
	lw	$t4, saveReg+4	

####################
#
# preSaveReg
# Called to load 
#
####################
preSaveReg:
	lw 	$ra, saveReg
	jr	$ra

####################
#
# saveSymTab
# saves symTab
#
####################
saveSymTab:				
	sw	$a1, symTab+12($s1)	#inserting token into symtab
	sw	$t4, saveReg+4
	lw	$t4, token
	sw	$t4, symTab+0($s1)
	
	lw	$t4, token+4		#inserting second half of token into symTab
	sw	$t4, symTab+4($s1)
	
	add	$t8, $zero, $s1
	addi	$s1, $s1, 16		#incrementing symTab index
	
	lw	$t4, saveReg+4
	jr	$ra

####################
#
# printSymTab
# preps the printing of symTab,
# prints header
#
####################
printSymTab:					
	sw	$t0, saveReg+8			#storing saveReg into temp registers
	sw	$t1, saveReg+12
	sw	$t2, saveReg+16
	sw	$t3, saveReg+20
	
	li	$t4, 0
	li	$v0, 4
	la	$a0, header			#load header
	syscall
	la	$a0, dash			# load dashes
	syscall

####################
#
# repeat
# used to print elements of symTab
#
####################
repeat:						
	beq 	$t4, $s1, ret
	
	la	$t0, symTab($t4)
	lb	$t1, symTab+8($t4)
	li	$t2, '\0'
	
	sb	$t2, symTab+8($t4)		#prints token name
	move	$a0, $t0
	syscall
	
	sb	$t1, symTab+8($t4)		#prints gap
	addi	$t4, $t4, 8
	la	$a0, space
	syscall
	
	
	li	$v0, 34				#prints LOC
	lw	$a0, symTab($t4)
	addi	$t4, $t4, 4
	syscall
	
	li	$v0, 4				#prints gap between LOC and type
	la	$a0, space
	syscall
	
	la	$a0, hex_prefix			#prints hex prefix '0x' and type
	syscall
	li	$v0, 1
	lw	$a0, symTab($t4)
	addi	$t4, $t4, 4
	syscall
	
	li	$v0, 4				#prints new line character
	la	$a0, new_line
	syscall
	
	bc1f	repeat				#repeats for all labels

####################
#
# ret
# moves values from saveReg into temp registers
#
####################
ret:
	lw	$t0, saveReg+8			
	lw	$t1, saveReg+12
	lw	$t2, saveReg+16
	lw	$t3, saveReg+20
	jr	$ra

####################
#
# preSymACTS
# Called to load symACT into $s5, and exectues it
#
####################
preSymACTS:
	la 	$s5, symACTS 	# load address of symACTS to access the first line
	sll 	$a1, $a1, 2 	# newStatus * 8
	add 	$s5, $s5, $a1 	# calculate the address of the correct symACT
	sra 	$a1, $a1, 2 
	jr 	$s5

####################
#
# symACTS
# 
#
####################
symACTS:
	b symACT0
	b symACT1
	b symACT2
	b symACT3
	b symACT4
	b symACT5

####################
#
# symACT0
# 
#
####################
symACT0:
	lw	$t1, symTab+8($t8)
	sw	$s0, symTab+8($t8)
	b	preSaveReg

####################
#
# symACT1
# 
#
####################
symACT1:
	lw	$t1, symTab+8($t8)
	sw	$s0, symTab+8($t8)
	b	preSaveReg

####################
#
# symACT2
# 
#
####################
symACT2:
	lw	$t1, symTab+8($t8)
	b	preSaveReg

####################
#
# symACT3
# 
#
####################
symACT3:
	la	$a0, error_message
	li	$v0, 4
	syscall
	li	$t1, -1
	b	preSaveReg
		
####################
#
# symACT4
# 
#
####################
symACT4:
	sw	$s0, symTab+8($t8)
	li	$t1, -1
	b	preSaveReg
	
		
####################
#
# symACT5
# 
#
####################	
symACT5:
	sw	$s0, symTab+8($t8)
	li	$t1, 0
	b	preSaveReg
	
####################
#
# searchSymTab
# Searches symTab, resets oldStatus
#
####################	
searchSymTab:
	sw	$t4, saveReg+4
	sw	$t3, saveReg+8
	sw	$t2, saveReg+12
	li	$t4, 0				# i index
	li	$t8, -1
				
####################
#
# tokenSearch
# searches tokens for previously defined tokens
#
####################
tokenSearch:
	bge	$t4, $s1, srchEnd
	lw	$t3, token
	lw	$t2, symTab($t4)
	bne	$t3, $t2, updateOldStatus
	
	lw	$t3, token+4
	lw	$t2, symTab+4($t4)
	bne	$t3, $t2, updateOldStatus
	
	add	$t8, $zero, $t4
	j	srchEnd

####################
#
# updateOldStatus
# updates oldStatus by 16
#
####################
updateOldStatus:
	addi	$t4, $t4, 16
	b	tokenSearch

####################
#
# srchEnd
# jumped to when search is over,
# stores saveReg values in temp registers
#
####################
srchEnd:
	lw	$t0, saveReg+4
	lw	$t1, saveReg+8
	lw	$t2, saveReg+12
	jr	$ra

####################
#
# ACT1
# 
#
####################							
ACT1:
	lb	$a0, inBuf($s2)		
	jal	lin_search			
	addi	$s2, $s2, 1			
	jr	$v1		

####################
#
# ACT2
# 
#
####################							
ACT2:												
	li	$a3, 0				
	sb	$a0, token($a3)			
	addi	$t0, $s5, 0x30			
	sb	$t0, token+10($a3)		
	li	$t0, '\n'
	sb	$t0, token+11($a3)		
	addi	$a3, $a3, 1
	jr 	$v1															

####################
#
# ACT3
# 
#
####################																																					
ACT3:
	bgt	$a3, 7, tooLong		
	sb	$a0, token($a3)			
	addi	$a3, $a3, 1			
	jr	$v1	
tooLong:
	li	$s5, 7				
	jr	$v1
	
####################
#
# ACT4
# 
#
####################
ACT4:
	lw	$t0, token($0)			
	sw	$t0, tokArray($s3)		
	lw	$t0, token+4($0)		
	sw	$t0, tokArray+4($s3)		
	lw	$t0, token+8($0)		
	sw	$t0, tokArray+8($s3)		
	addi	$s3, $s3, 12			
	
	jal	clearTok			
	jr	$v1

####################
#
# RETURN
# 
#
####################
RETURN:
	sw	$zero, tokArray($s3)		
	b	dump				

####################
#
# ERROR
# 
#
####################
ERROR:
	la	$a0, error_message			# print error occurrence
	li	$v0, 4
	syscall
	b	dump

####################
#
# clearTok
# clears the token
#
####################
clearTok:
	li	$t1, 0x20202020
	sw	$t1, token($0)
	sw	$t1, token+4($0)
	sw	$t1, token+8($0)
	jr	$ra

####################
#
# prints inBuf
# 
#
####################
printLine:
	la	$a0, inBuf			# input Buffer address
	li	$v0,4
	syscall
	jr	$ra

####################
#
# printTokArray
# prints tokArray
#
####################
printTokArray:
	la	$a0, header			# table heading
	li	$v0, 4
	syscall

	la	$a0, tokArray			# print tokArray
	li	$v0, 4
	syscall

	jr	$ra

####################
#
# clearInBuf
# clears inBuf for next input
#
####################
clearInBuf:
	li	$t0,0
cleaningBuf:
	bge	$t0, 80, buffCleaned
	sw	$zero, inBuf($t0)		# clear inBuf to 0x0
	addi	$t0, $t0, 4
	b	cleaningBuf
buffCleaned:
	jr	$ra
	
####################
#
# clearTokArray
# clears the tokArray
#
####################																												
clearTokArray:
	li	$t0, 0
	li	$t1, 0x20202020
cleaningCTok:
	bge	$t0, $a3, CTokCleaned
	sw	$t1, tokArray($t0)		# clear
	sw	$t1, tokArray+4($t0)		#  3-word entry
	sw	$t1, tokArray+8($t0)		#  in tokArray
	addi	$t0, $t0, 12
	b	cleaningCTok
CTokCleaned:																																																				
	jr	$ra

####################
#
# getLine
# 
#
####################																																																																																																																																																																				
getline:
	la	$a0, prompt			# Prompt to enter a new line
	li	$v0, 4
	syscall

	la	$a0, inBuf			# read a new line
	li	$a1, 80	
	li	$v0, 8
	syscall
	jr	$ra
	
####################
#
# lin_search
# searches key against tabChar, returns to $s5
#
####################																																																																																																																																																																																																																																																																																																																																			
lin_search:
	li	$t0,0				# index to Tabchar
	li	$s5, 7	
searching:
	lb	$t1, Tabchar($t0)
	beq	$t1, 0x7F, searchFailure
	beq	$t1, $a0, searchSuccess
	addi	$t0, $t0, 8
	b	searching
searchSuccess:
	lw	$s5, Tabchar+4($t0)		# return char type
searchFailure:																																																																																																																																																																																																																																																					
	jr	$ra
																																																																																																																																																																																																																																																																																																																																																																																																																									
	.data

STAB:
Q0:     .word  ACT1
        .word  Q1   # T1
        .word  Q1   # T2
        .word  Q1   # T3
        .word  Q1   # T4
        .word  Q1   # T5
        .word  Q1   # T6
        .word  Q11  # T7

Q1:     .word  ACT2
        .word  Q2   # T1
        .word  Q5   # T2
        .word  Q3   # T3
        .word  Q3   # T4
        .word  Q0   # T5
        .word  Q4   # T6
        .word  Q11  # T7

Q2:     .word  ACT1
        .word  Q6   # T1
        .word  Q7   # T2
        .word  Q7   # T3
        .word  Q7   # T4
        .word  Q7   # T5
        .word  Q7   # T6
        .word  Q11  # T7

Q3:     .word  ACT4
        .word  Q0   # T1
        .word  Q0   # T2
        .word  Q0   # T3
        .word  Q0   # T4
        .word  Q0   # T5
        .word  Q0   # T6
        .word  Q11  # T7

Q4:     .word  ACT4
        .word  Q10  # T1
        .word  Q10  # T2
        .word  Q10  # T3
        .word  Q10  # T4
        .word  Q10  # T5
        .word  Q10  # T6
        .word  Q11  # T7

Q5:     .word  ACT1
        .word  Q8   # T1
        .word  Q8   # T2
        .word  Q9   # T3
        .word  Q9   # T4
        .word  Q9   # T5
        .word  Q9   # T6
        .word  Q11  # T7

Q6:     .word  ACT3
        .word  Q2   # T1
        .word  Q2   # T2
        .word  Q2   # T3
        .word  Q2   # T4
        .word  Q2   # T5
        .word  Q2   # T6
        .word  Q11  # T7

Q7:     .word  ACT4
        .word  Q1   # T1
        .word  Q1   # T2
        .word  Q1   # T3
        .word  Q1   # T4
        .word  Q1   # T5
        .word  Q1   # T6
        .word  Q11  # T7

Q8:     .word  ACT3
        .word  Q5   # T1
        .word  Q5   # T2
        .word  Q5   # T3
        .word  Q5   # T4
        .word  Q5   # T5
        .word  Q5   # T6
        .word  Q11  # T7

Q9:     .word  ACT4
        .word  Q1  # T1
        .word  Q1  # T2
        .word  Q1  # T3
        .word  Q1  # T4
        .word  Q1  # T5
        .word  Q1  # T6
        .word  Q11 # T7

Q10:	.word	RETURN
        .word  Q10  # T1
        .word  Q10  # T2
        .word  Q10  # T3
        .word  Q10  # T4
        .word  Q10  # T5
        .word  Q10  # T6
        .word  Q11  # T7

Q11:    .word  ERROR 
	.word  Q4  # T1
	.word  Q4  # T2
	.word  Q4  # T3
	.word  Q4  # T4
	.word  Q4  # T5
	.word  Q4  # T6
	.word  Q4  # T7
	
	
Tabchar: 
	.word ' ', 5
 	.word '#', 6
 	.word '$', 4 
	.word '(', 4
	.word ')', 4 
	.word '*', 3 
	.word '+', 3 
	.word ',', 4 
	.word '-', 3 
	.word '.', 4 
	.word '/', 3 

	.word '0', 1
	.word '1', 1 
	.word '2', 1 
	.word '3', 1 
	.word '4', 1 
	.word '5', 1 
	.word '6', 1 
	.word '7', 1 
	.word '8', 1 
	.word '9', 1 

	.word ':', 4 

	.word 'A', 2
	.word 'B', 2 
	.word 'C', 2 
	.word 'D', 2 
	.word 'E', 2 
	.word 'F', 2 
	.word 'G', 2 
	.word 'H', 2 
	.word 'I', 2 
	.word 'J', 2 
	.word 'K', 2
	.word 'L', 2 
	.word 'M', 2 
	.word 'N', 2 
	.word 'O', 2 
	.word 'P', 2 
	.word 'Q', 2 
	.word 'R', 2 
	.word 'S', 2 
	.word 'T', 2 
	.word 'U', 2
	.word 'V', 2 
	.word 'W', 2 
	.word 'X', 2 
	.word 'Y', 2
	.word 'Z', 2

	.word 'a', 2 
	.word 'b', 2 
	.word 'c', 2 
	.word 'd', 2 
	.word 'e', 2 
	.word 'f', 2 
	.word 'g', 2 
	.word 'h', 2 
	.word 'i', 2 
	.word 'j', 2 
	.word 'k', 2
	.word 'l', 2 
	.word 'm', 2 
	.word 'n', 2 
	.word 'o', 2 
	.word 'p', 2 
	.word 'q', 2 
	.word 'r', 2 
	.word 's', 2 
	.word 't', 2 
	.word 'u', 2
	.word 'v', 2 
	.word 'w', 2 
	.word 'x', 2 
	.word 'y', 2
	.word 'z', 2

	.word 0x7F, 0
